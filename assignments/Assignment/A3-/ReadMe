
# Ethereum Summary Notes

## Chapter 1: What Is Ethereum?

### Overview
Ethereum is a decentralized "world computer" distributed across thousands of nodes worldwide, with no single entity in control. It maintains a shared global state (like a universal scoreboard) that stays consistent across all participants.

From a practical perspective:
- An open platform for building **smart contracts** (self-executing programs).
- Secured by blockchain technology.
- Powered by **ether (ETH)** as "fuel" for computations.

**Key benefits**: High reliability, transparency, censorship resistance, and reduced need for trusted intermediaries.

### Ethereum vs. Bitcoin

| Aspect              | Bitcoin                          | Ethereum                              |
|---------------------|----------------------------------|---------------------------------------|
| Primary Purpose     | Digital money for payments       | Platform for apps; ETH as fuel        |
| Scripting           | Simple rules (limited operations)| Turing-complete (full programs)       |
| Major Upgrade       | N/A                              | 2022 "The Merge" → Proof of Stake     |

### Components of a Blockchain
All public blockchains share:
- P2P network of nodes
- Transactions
- Consensus rules
- State machine
- Chained blocks with cryptographic security
- Consensus mechanism
- Incentives/rewards
- Client software

Ethereum formalizes these in its **Yellow Paper** (mathematical specification).

**Blockchain types**:
- **Permissionless** (open like Ethereum/Bitcoin) vs. **Permissioned**
- **Public** vs. **Private**

### The Birth of Ethereum
Proposed by Vitalik Buterin in 2013 to overcome Bitcoin's limitations. Gavin Wood contributed significantly. Launched in July 2015 as a programmable "world computer." Enabled innovations like DeFi, NFTs, and DAOs.

### Ethereum’s Development Stages
- **Frontier (2015)**: Initial launch for testing/mining
- **Homestead (2016)**: Stabilization
- **Metropolis (2017–2020)**: Usability/security improvements
- **Serenity (Ethereum 2.0, ongoing)**: Proof of Stake transition and scalability upgrades

Ongoing phases:
- **The Merge** (completed): Proof of Stake
- **The Surge**: Sharding for scalability
- **The Scourge**: Mitigate centralization
- **The Verge**: Simplify node operation
- **The Purge**: Remove historical data
- **The Splurge**: Miscellaneous improvements

### Ethereum as a General-Purpose Blockchain
Unlike Bitcoin (tracks only coin ownership), Ethereum tracks arbitrary data and executes code—like a global shared computer with persistent memory.

**Key components**:
- ÐΞVp2p network protocol
- Transactions (with value + data)
- Ethereum Virtual Machine (EVM)
- State stored in Merkle trees
- Proof of Stake (Gasper consensus)
- Multiple clients (Geth, Nethermind, etc.)

### Turing Completeness
Ethereum is **Turing complete**—capable of running any computable program (named after Alan Turing).

**Power**: Enables complex logic.  
**Risk**: Infinite loops could halt the network.

**Mitigation**: **Gas system**—every operation costs gas (paid in ETH). Transactions have gas limits; running out halts execution safely.

### From DApps to Web3
Ethereum enabled **DApps** (decentralized applications) = smart contracts + frontend (often hybrid with centralized elements for performance).

Represents **Web3**: A decentralized internet where users own data/assets (vs. Web2's corporate control).

### Development Culture & Why Learn Ethereum
Ethereum evolves rapidly ("move fast and break things") compared to Bitcoin's conservatism. Largest developer ecosystem, beginner-friendly (especially with JavaScript/Solidity knowledge), and powers most blockchain innovation.

**Conclusion**: Ethereum is a programmable blockchain transforming trustless applications and the future of the internet.

## Chapter 6: Transactions

### What Are Transactions?
Transactions are signed instructions from user accounts (Externally Owned Accounts) that change the blockchain state—e.g., transfer ETH or execute contract code. Nothing happens automatically; contracts only run when triggered by a transaction.

Ethereum acts as a global computer, and transactions are the inputs that drive it.
### Transaction Structure (as of 2025)
Transactions are serialized (RLP-encoded) bundles with a type indicator. Main types:

- **Legacy**: Original format (nonce, gas price/limit, to, value, data, signature)
- **EIP-2930**: Adds access list for cheaper gas
- **EIP-1559**: Modern fee market (base fee burned + priority tip)
- **EIP-4844**: Blob-carrying (for Layer 2 data)
- **EIP-7702**: Allows temporary contract-like behavior for EOAs

### The Nonce
A sequential counter (starting at 0) per account:
- Ensures correct ordering
- Prevents replay attacks

Critical for developers—mismanaged nonces can block queues.

### Gas in Transactions
Gas measures computational work:
- Gas limit: Max you're willing to spend
- Only pay for gas used
- EIP-1559 splits fees (base burned, tip to builder)

Wallets auto-suggest optimal settings.

### Recipient ("To" Field)
Can be an EOA or contract. Invalid addresses permanently burn funds.

### Value and Data Fields
- **Value**: ETH amount (can be 0)
- **Data**: Code/instructions (e.g., function calls)

Combinations enable transfers, contract calls, or both.

### Transaction Lifecycle
1. Created and signed
2. Broadcast to network
3. Included in a block by builders
4. Finalized (~12 minutes for safety)

**Conclusion**: Transactions are the heartbeat of Ethereum—triggering all state changes. Understanding them is essential for deeper topics like smart contract development.

# Anatomy of a Blockchain Transaction

A blockchain transaction is a recorded action on the network, such as transferring cryptocurrency (e.g., ETH) or interacting with a smart contract. In Ethereum and similar blockchains, transactions are the fundamental way the state of the network changes—they trigger transfers, contract executions, or other operations.

Once confirmed and included in a block, transactions become **immutable**: permanently recorded, publicly verifiable, and impossible to alter. This immutability and transparency are core strengths of decentralized networks.
## Key Fields in a Transaction

Every transaction contains several essential fields that ensure security, transparency, and proper execution:

- **Transaction Hash**  
  A unique identifier (digital fingerprint) generated from the transaction data. It allows anyone to look up and track the transaction on a blockchain explorer like Etherscan.

- **From Address**  
  The sender's wallet address (an Externally Owned Account). This is the account that signs and initiates the transaction.

- **To Address**  
  The recipient's address. This can be another wallet (for simple transfers) or a smart contract address (for interactions).

- **Value**  
  The amount of native cryptocurrency (e.g., ETH) being transferred. Can be zero for contract calls that don't send funds.

- **Gas Limit**  
  The maximum amount of gas (computational units) the sender is willing to spend. Protects against excessive resource usage.

- **Gas Fees**  
  The actual cost paid to validators for processing the transaction. Calculated as gas used × effective gas price (includes base fee + priority tip in modern EIP-1559 transactions).

- **Nonce**  
  A sequential counter unique to the sender's address. Prevents replay attacks and ensures transactions are processed in the correct order.

- **Input Data**  
  Encoded instructions for smart contracts (e.g., function calls and parameters). Empty for simple ETH transfers.

- **Status**  
  Indicates the outcome: Pending (awaiting inclusion), Success, or Failed (e.g., out of gas or reverted by contract logic).

These fields are bundled, signed with the sender's private key, broadcast to the network, and eventually included in a block. Public visibility of all fields enables anyone to verify activity and builds trust in the decentralized system.


# Merkle Tree Root Calculation with ethers.js

## Overview

This script provide a clear, educational demonstration of building a Merkle tree root from a list of simple transaction-like strings. Using the ethers.js library, it hashes the input data as leaves and recursively constructs the tree by pairwise concatenation and hashing.

This computes two separate roots:
- One using SHA256
- One using Keccak256 (Ethereum's standard hash function)

This highlights how the choice of hash algorithm dramatically affects the final root, even with identical input data and tree structure. It also logs intermediate levels to show the step-by-step pairing process.

## Development Process – Step by Step

1. **Define sample transactions**: Created an array of 6 human-readable strings representing mock transfers (e.g., "Chibex sent 100USD") to act as Merkle tree leaves.

2. **Leaf hashing**: Implemented `hashLeaves` to convert each string to UTF-8 bytes with `ethers.toUtf8Bytes` and then apply the chosen hash function. This produces the initial layer of cryptographic hashes.

3. **Tree building function**: Wrote a recursive `buildMerkleRoot` function that:
   - Returns immediately if only one hash remains (the root).
   - Iterates in steps of 2, concatenating pairs with `ethers.concat` and hashing the result.
   - Promotes the last hash unchanged if the level has an odd number of elements.
   - Logs each new level for visibility into the reduction process.
   - Recurses until the single root is reached.

4. **Dual computation**: Executed the process twice—once with `ethers.sha256` and once with `ethers.keccak256`—to directly compare outcomes.

5. **Output logging**: Added console logs for leaves, intermediate levels (via the builder), and final roots to make the tree construction transparent.

## Packages Used

- **ethers**: The ethers.js library (version 6+ recommended for ES module `import` syntax).
  - Provides essential utilities: `sha256`, `keccak256`, `toUtf8Bytes`, and `concat`.
  - No other functions or heavy dependencies are used.
  - Installation: `npm install ethers`

## Running the Code

1. Save the code to a file (e.g., `Block.js`).
2. Install the dependency: `npm install ethers`
3. Execute: `node Block.js`

## Result Preview

Sample console output (actual values shown are for SHA256; Keccak256 produces entirely different hashes but follows the same structure and logging pattern):

```
Leaves (SHA256): [
  '0x94a4df2a45e2e3422653b091c28d3a72f31a109b8662713ae7514c29b0e54262',
  '0x10cf8f607ff486295d5a30860a6b3036745fc640c3ba5bcfeed161ad0759b76d',
  '0x6d42c8ecce148319129f076fbefabcc1f32f38eb7a5a1af79e4ebb1de372237a',
  '0x54f53a5b7c4e908055a309873b87a0a0744e78c4fd66e4dd3535a2b05e6a963b',
  '0x1d349745aebe3e89c437a75939475ee03c9413d978abfa39a9315f6c90ad101d',
  '0x2447bace3e9dba631d4955e1a0749d31134f71c343bdf382a9a685c010db2d76'
]
Next level: [
  '0x6ead38a07b2d7638f499c011988750f3308b38fb94ee0c25fda0408b2ba66dfc',
  '0x2bd388628774a9c1804072526ff9aba3332f40cb5e825a839976c9977d93b87b',
  '0x80f51b212c382a74d81fd880034ad0bbc8b4a4abe7a1501f37f1ee4ab1674977'
]
Next level: [
  '0x771ab98e94b1a7788f521442e537755d4a2394a15363ac63bf21cbfa9d50404c',
  '0x80f51b212c382a74d81fd880034ad0bbc8b4a4abe7a1501f37f1ee4ab1674977'
]
Next level: [ '0xc75f0fc609ef242cde5b10b8748355c2d8a8e71c12116a48d2808fef0ea7c5ae' ]
Merkle Root (SHA256): 0xc75f0fc609ef242cde5b10b8748355c2d8a8e71c12116a48d2808fef0ea7c5ae
Merkle Root (Keccak256): 0x...different-hex-value...
```

The logs clearly show the reduction: 6 leaves → 3 → 2 → 1 root. Running the script yourself will display the exact Keccak256 values, which are the ones relevant to Ethereum protocols.
