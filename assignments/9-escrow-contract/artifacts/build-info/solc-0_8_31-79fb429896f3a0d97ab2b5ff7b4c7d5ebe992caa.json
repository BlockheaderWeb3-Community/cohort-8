{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_31-79fb429896f3a0d97ab2b5ff7b4c7d5ebe992caa",
  "solcVersion": "0.8.31",
  "solcLongVersion": "0.8.31+commit.fd3a2265",
  "userSourceNameMap": {
    "contracts/Escrow.sol": "project/contracts/Escrow.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "osaka",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Escrow.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.31;\n\ncontract Escrow {\n  uint public transactionCount = 1;\n  address public contractAddress;\n\n  enum State {\n    AWAITING_PAYMENT,\n    AWAITING_DELIVERY,\n    AWAITING_FUNDS_DISBURSEMENT,\n    COMPLETE\n  }\n\n  struct Order {\n    uint id;\n    address buyer;\n    address seller;\n    uint amount;\n    State status;\n  }\n\n  mapping(uint => Order) public orders;\n\n  constructor() {\n    contractAddress = msg.sender;\n  }\n\n  modifier notAddressZero(address _addr) {\n    require(_addr != address(0), 'Address cant be address zero');\n    _;\n  }\n\n  modifier onlyBuyer(uint _id) {\n    require(\n      msg.sender == orders[_id].buyer,\n      'Only buyer can call this function'\n    );\n    _;\n  }\n\n  modifier onlySeller(uint _id) {\n    require(\n      msg.sender == orders[_id].seller,\n      'Only seller can call this function'\n    );\n    _;\n  }\n\n  modifier onlyContract() {\n    require(\n      msg.sender == contractAddress,\n      'Only Contract can call this function'\n    );\n    _;\n  }\n\n  modifier validState(uint _id, State _state) {\n    require(_state == orders[_id].status, 'Invalid state');\n    _;\n  }\n\n  modifier paymentMade(uint _id) {\n    require(\n      address(this).balance >= orders[_id].amount && address(this).balance > 0,\n      'Amount not paid'\n    );\n    _;\n  }\n\n  function createOrder(address _buyer, address _seller) public {\n    require(_buyer != address(0), 'Address cant be address zero');\n    require(_seller != address(0), 'Address cant be address zero');\n    orders[transactionCount].id = transactionCount;\n    orders[transactionCount].buyer = _buyer;\n    orders[transactionCount].seller = _seller;\n    orders[transactionCount].status = State.AWAITING_PAYMENT;\n    transactionCount++;\n  }\n\n  function deposit(\n    uint _id\n  ) public payable onlyBuyer(_id) validState(_id, State.AWAITING_PAYMENT) {\n    orders[_id].amount = msg.value;\n    orders[_id].status = State.AWAITING_DELIVERY;\n  }\n\n  function sendDelivery(\n    uint _transactionCount\n  )\n    public\n    paymentMade(_transactionCount)\n    validState(_transactionCount, State.AWAITING_DELIVERY)\n  {\n    orders[_transactionCount].status = State.AWAITING_FUNDS_DISBURSEMENT;\n  }\n\n  function releaseFundsToSeller(\n    uint _id\n  )\n    external\n    onlyContract\n    paymentMade(_id)\n    validState(_id, State.AWAITING_FUNDS_DISBURSEMENT)\n  {\n    Order memory _order = orders[_id];\n\n    (bool success, ) = _order.seller.call{value: _order.amount}('');\n    require(success, 'Transfer failed');\n    _order.status = State.COMPLETE;\n    orders[_id] = _order;\n  }\n\n  function refundFundsToBuyer(\n    uint _id\n  )\n    external\n    onlyContract\n    paymentMade(_id)\n    validState(_id, State.AWAITING_DELIVERY)\n  {\n    Order storage _order = orders[_id];\n\n    (bool success, ) = _order.buyer.call{value: _order.amount}('');\n    require(success, 'Refund failed');\n  }\n}\n"
      }
    }
  }
}