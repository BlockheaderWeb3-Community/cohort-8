{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-90a9f09f6a4f098ca55bdce3293f36afd461b7cb",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/auction/contracts/auction.sol": "project/contracts/auction/contracts/auction.sol",
    "contracts/client/contracts/client.sol": "project/contracts/client/contracts/client.sol",
    "contracts/counter/contracts/Counter.sol": "project/contracts/counter/contracts/Counter.sol",
    "contracts/crowdfund/contracts/crownfund.sol": "project/contracts/crowdfund/contracts/crownfund.sol",
    "contracts/escrow/contracts/Escrow.sol": "project/contracts/escrow/contracts/Escrow.sol",
    "contracts/escrow/contracts/MultiEscrow.sol": "project/contracts/escrow/contracts/MultiEscrow.sol",
    "contracts/todo/contracts/Todo.sol": "project/contracts/todo/contracts/Todo.sol",
    "contracts/vault/contracts/vault.sol": "project/contracts/vault/contracts/vault.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/auction/contracts/auction.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract SimpleAuction {\n  bool private locked;\n\n  modifier nonReentrant() {\n    require(!locked, \"Reentrancy\");\n    locked = true;\n    _;\n    locked = false;\n  }\n  address public owner;\n  uint256 public startingPrice;\n  uint256 public endTime;\n  bool public ended;\n\n  address public highestBidder;\n  uint256 public highestBid;\n\n  mapping(address => uint256) public pendingReturns;\n\n  event BidPlaced(address indexed bidder, uint256 amount);\n  event AuctionEnded(address winner, uint256 amount);\n  event RefundWithdrawn(address indexed bidder, uint256 amount);\n\n  constructor(uint256 _startingPrice, uint256 _auctionDuration) {\n    require(_startingPrice > 0, \"Starting price must be > 0\");\n    require(_auctionDuration > 0, \"Duration must be > 0\");\n    owner = msg.sender;\n    startingPrice = _startingPrice;\n    endTime = block.timestamp + _auctionDuration;\n    highestBid = _startingPrice;\n  }\n\n  function bid() public payable {\n    require(block.timestamp < endTime, \"Auction ended\");\n    require(!ended, \"Auction already ended\");\n    require(msg.sender != owner, \"Owner cannot bid\");\n    require(msg.value > highestBid, \"Bid too low\");\n\n    if (highestBidder != address(0)) {\n      pendingReturns[highestBidder] += highestBid;\n    }\n\n    highestBidder = msg.sender;\n    highestBid = msg.value;\n    emit BidPlaced(msg.sender, msg.value);\n  }\n\n  function withdrawRefund() external nonReentrant {\n    uint256 amount = pendingReturns[msg.sender];\n    require(amount > 0, \"No refund\");\n    pendingReturns[msg.sender] = 0;\n    (bool ok, ) = payable(msg.sender).call{value: amount}(\"\");\n    require(ok, \"Refund failed\");\n    emit RefundWithdrawn(msg.sender, amount);\n  }\n\n  function endAuction() external nonReentrant {\n    require(msg.sender == owner, \"Only owner\");\n    require(block.timestamp >= endTime, \"Auction not ended\");\n    require(!ended, \"Already ended\");\n    ended = true;\n    if (highestBidder != address(0)) {\n      (bool ok, ) = payable(owner).call{value: highestBid}(\"\");\n      require(ok, \"Payout failed\");\n    }\n    emit AuctionEnded(highestBidder, highestBidder == address(0) ? 0 : highestBid);\n  }\n\n  receive() external payable {\n    bid();\n  }\n}\n"
      },
      "project/contracts/client/contracts/client.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract MilestoneEscrow {\n  struct Job {\n    address client;\n    address freelancer;\n    uint256 milestoneCount;\n    uint256 amountPerMilestone;\n    bool funded;\n    uint256 paidCount;\n    bool[] completed;\n    bool[] approved;\n  }\n\n  uint256 public nextJobId;\n  mapping(uint256 => Job) private jobs;\n\n  event JobCreated(uint256 jobId, address client, address freelancer, uint256 milestoneCount, uint256 amountPerMilestone);\n  event JobFunded(uint256 jobId, uint256 totalAmount);\n  event MilestoneCompleted(uint256 jobId, uint256 milestoneIndex);\n  event MilestoneApproved(uint256 jobId, uint256 milestoneIndex, uint256 amountPaid);\n  event JobCompleted(uint256 jobId);\n\n  function createJob(address freelancer, uint256 milestoneCount, uint256 amountPerMilestone) external returns (uint256) {\n    require(freelancer != address(0), \"Freelancer cannot be zero\");\n    require(freelancer != msg.sender, \"Client cannot be freelancer\");\n    require(milestoneCount > 0, \"Milestones must be > 0\");\n    require(amountPerMilestone > 0, \"Amount must be > 0\");\n\n    uint256 jobId = nextJobId;\n    nextJobId = jobId + 1;\n\n    Job storage job = jobs[jobId];\n    job.client = msg.sender;\n    job.freelancer = freelancer;\n    job.milestoneCount = milestoneCount;\n    job.amountPerMilestone = amountPerMilestone;\n    job.funded = false;\n    job.paidCount = 0;\n    job.completed = new bool[](milestoneCount);\n    job.approved = new bool[](milestoneCount);\n\n    emit JobCreated(jobId, msg.sender, freelancer, milestoneCount, amountPerMilestone);\n    return jobId;\n  }\n\n  function fundJob(uint256 jobId) external payable {\n    Job storage job = jobs[jobId];\n    require(msg.sender == job.client, \"Only client can fund\");\n    require(!job.funded, \"Already funded\");\n    require(job.milestoneCount > 0, \"Job not found\");\n    uint256 total = job.milestoneCount * job.amountPerMilestone;\n    require(msg.value == total, \"Incorrect funding amount\");\n\n    job.funded = true;\n    emit JobFunded(jobId, total);\n  }\n\n  function markCompleted(uint256 jobId, uint256 milestoneIndex) external {\n    Job storage job = jobs[jobId];\n    require(msg.sender == job.freelancer, \"Only freelancer\");\n    require(job.funded, \"Not funded\");\n    require(milestoneIndex < job.milestoneCount, \"Invalid milestone\");\n    require(!job.completed[milestoneIndex], \"Already completed\");\n\n    job.completed[milestoneIndex] = true;\n    emit MilestoneCompleted(jobId, milestoneIndex);\n  }\n\n  function approveMilestone(uint256 jobId, uint256 milestoneIndex) external {\n    Job storage job = jobs[jobId];\n    require(msg.sender == job.client, \"Only client\");\n    require(job.funded, \"Not funded\");\n    require(milestoneIndex < job.milestoneCount, \"Invalid milestone\");\n    require(job.completed[milestoneIndex], \"Not completed\");\n    require(!job.approved[milestoneIndex], \"Already approved\");\n\n    job.approved[milestoneIndex] = true;\n    job.paidCount += 1;\n\n    (bool ok, ) = payable(job.freelancer).call{value: job.amountPerMilestone}(\"\");\n    require(ok, \"Payment failed\");\n    emit MilestoneApproved(jobId, milestoneIndex, job.amountPerMilestone);\n\n    if (job.paidCount == job.milestoneCount) {\n      emit JobCompleted(jobId);\n    }\n  }\n\n  function getJob(uint256 jobId)\n    external\n    view\n    returns (\n      address client,\n      address freelancer,\n      uint256 milestoneCount,\n      uint256 amountPerMilestone,\n      bool funded,\n      uint256 paidCount\n    )\n  {\n    Job storage job = jobs[jobId];\n    return (job.client, job.freelancer, job.milestoneCount, job.amountPerMilestone, job.funded, job.paidCount);\n  }\n\n  function milestoneStatus(uint256 jobId, uint256 milestoneIndex) external view returns (bool isCompleted, bool isApproved) {\n    Job storage job = jobs[jobId];\n    require(milestoneIndex < job.milestoneCount, \"Invalid milestone\");\n    return (job.completed[milestoneIndex], job.approved[milestoneIndex]);\n  }\n}\n"
      },
      "project/contracts/counter/contracts/Counter.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract Counter {\n  uint public x;\n\n  event Increment(uint by);\n\n  function inc() public {\n    x++;\n    emit Increment(1);\n  }\n\n  function incBy(uint by) public {\n    require(by > 0, \"incBy: increment should be positive\");\n    x += by;\n    emit Increment(by);\n  }\n}\n"
      },
      "project/contracts/crowdfund/contracts/crownfund.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract SimpleCrowdfunding {\n  bool private locked;\n\n  modifier nonReentrant() {\n    require(!locked, \"Reentrancy\");\n    locked = true;\n    _;\n    locked = false;\n  }\n  address public owner;\n  uint256 public goal;\n  uint256 public deadline;\n  uint256 public totalRaised;\n  bool public withdrawn;\n\n  mapping(address => uint256) public contributions; // Tracks each contributor's amount.\n\n  event Contribution(address indexed contributor, uint256 amount);\n  event Withdraw(address indexed owner, uint256 amount);\n  event Refund(address indexed contributor, uint256 amount);\n\n  constructor(uint256 _goal, uint256 _deadline) {\n    require(_goal > 0, \"Goal must be > 0\");\n    require(_deadline > block.timestamp, \"Deadline must be future\");\n    owner = msg.sender;\n    goal = _goal;\n    deadline = _deadline;\n  }\n\n  function contribute() public payable {\n    require(block.timestamp < deadline, \"Funding ended\");\n    require(msg.value > 0, \"Must send ETH\");\n    require(!withdrawn, \"Already withdrawn\");\n    contributions[msg.sender] += msg.value;\n    totalRaised += msg.value;\n    emit Contribution(msg.sender, msg.value);\n  }\n\n  function withdraw() external nonReentrant {\n    require(msg.sender == owner, \"Only owner\");\n    require(totalRaised >= goal, \"Goal not met\");\n    require(!withdrawn, \"Already withdrawn\");\n    withdrawn = true;\n    uint256 amount = address(this).balance;\n    (bool ok, ) = payable(owner).call{value: amount}(\"\");\n    require(ok, \"Withdraw failed\");\n    emit Withdraw(owner, amount);\n  }\n\n  function refund() external nonReentrant {\n    require(block.timestamp >= deadline, \"Too early\");\n    require(totalRaised < goal, \"Goal met\");\n    uint256 amount = contributions[msg.sender];\n    require(amount > 0, \"No contribution\");\n    contributions[msg.sender] = 0;\n    (bool ok, ) = payable(msg.sender).call{value: amount}(\"\");\n    require(ok, \"Refund failed\");\n    emit Refund(msg.sender, amount);\n  }\n\n  receive() external payable {\n    contribute();\n  }\n}\n"
      },
      "project/contracts/escrow/contracts/Escrow.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract basicEscrow {\n  address public buyer;\n  address public seller;\n  address public owner;\n\n  enum EscrowState {\n    AWAITING_PAYMENT,\n    AWAITING_DELIVERY,\n    COMPLETE\n  }\n\n  EscrowState public state;\n\n  constructor(address _seller, address _owner) {\n    buyer = msg.sender;\n    require(_seller != address(0), 'Seller cannot be zero');\n    require(_seller != buyer, 'Seller cannot be buyer');\n    require(_owner != address(0), 'Owner cannot be zero');\n    require(_owner != buyer, 'Owner cannot be buyer');\n    seller = _seller;\n    owner = _owner;\n    state = EscrowState.AWAITING_PAYMENT;\n  }\n\n  // Buyers Deposit Eth\n  function deposit() external payable {\n    require(msg.sender == buyer, 'Only the buyer can deposit Eth');\n    require(state == EscrowState.AWAITING_PAYMENT, 'Payment already received');\n    require(msg.value > 0, 'Must send Eth');\n    state = EscrowState.AWAITING_DELIVERY;\n  }\n\n  // Buyers Confirmation\n  function confirmDelivery() external {\n    require(msg.sender == buyer, 'Only the buyer can confirm');\n    require(state == EscrowState.AWAITING_DELIVERY, 'Not awaiting');\n    state = EscrowState.COMPLETE;\n  }\n\n  // Owner release funds\n  function fundsRelease() external {\n    require(msg.sender == owner, 'Only the owner can release funds');\n    require(state == EscrowState.COMPLETE, 'Not complete');\n    require(address(this).balance > 0, 'No funds to release');\n    payable(seller).transfer(address(this).balance);\n  }\n\n  // Owner refund funds\n  function fundsRefund() external {\n    require(msg.sender == owner, 'Only the owner can refund funds');\n    require(state == EscrowState.COMPLETE, 'Not complete');\n    require(address(this).balance > 0, 'No funds to refund');\n    payable(buyer).transfer(address(this).balance);\n  }\n}\n"
      },
      "project/contracts/escrow/contracts/MultiEscrow.sol": {
        "content": "\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract SimpleEscrow { // One escrow deal: buyer, seller, owner (arbiter).\n  enum EscrowState { \n    AWAITING_PAYMENT, \n    AWAITING_SELLER_CONFIRMATION, \n    AWAITING_BUYER_CONFIRMATION, \n    COMPLETE \n    }\n    \n  address public buyer;\n  address public seller;\n  address public owner;\n  uint256 public amount;\n  EscrowState public state;\n\n  constructor(address _buyer, address _seller, address _owner) {\n    require(_buyer != address(0), \"Buyer cannot be zero\");\n    require(_seller != address(0), \"Seller cannot be zero\");\n    require(_owner != address(0), \"Owner cannot be zero\");\n    require(_buyer != _seller, \"Buyer cannot be seller\");\n    require(_buyer != _owner, \"Buyer cannot be owner\");\n    require(_seller != _owner, \"Seller cannot be owner\");\n    buyer = _buyer;\n    seller = _seller;\n    owner = _owner;\n    state = EscrowState.AWAITING_PAYMENT;\n  }\n\n  function deposit() external payable {\n    require(msg.sender == buyer, \"Only buyer can deposit\");\n    require(state == EscrowState.AWAITING_PAYMENT, \"Not awaiting payment\");\n    require(msg.value > 0, \"Must send ETH\");\n    amount = msg.value;\n    state = EscrowState.AWAITING_SELLER_CONFIRMATION;\n  }\n\n  function confirmDelivery() external {\n    require(msg.sender == seller, \"Only seller can confirm\");\n    require(state == EscrowState.AWAITING_SELLER_CONFIRMATION, \"Not awaiting seller\");\n    state = EscrowState.AWAITING_BUYER_CONFIRMATION;\n  }\n\n  function confirmReceived() external {\n    require(msg.sender == buyer, \"Only buyer can confirm\");\n    require(state == EscrowState.AWAITING_BUYER_CONFIRMATION, \"Not awaiting buyer\");\n    state = EscrowState.COMPLETE;\n  }\n\n  function fundsRelease() external {\n    require(msg.sender == owner, \"Only owner can release\");\n    require(state == EscrowState.COMPLETE, \"Not complete\");\n    require(amount > 0, \"No funds\");\n    uint256 payout = amount;\n    amount = 0;\n    payable(seller).transfer(payout);\n  }\n\n  function fundsRefund() external {\n    require(msg.sender == owner, \"Only owner can refund\");\n    require(state == EscrowState.COMPLETE, \"Not complete\");\n    require(amount > 0, \"No funds\");\n    uint256 payout = amount;\n    amount = 0;\n    payable(buyer).transfer(payout);\n  }\n\n}\n\ncontract MultiEscrowFactory { // Deploys many SimpleEscrow contracts and tracks them by id.\n  uint256 public nextId;\n  mapping(uint256 => address) public escrowById;\n  address[] public escrows;\n\n  event EscrowCreated(address escrow, address buyer, address seller, address owner);\n\n  function createEscrow(address _seller, address _owner) external returns (uint256, address) {\n    SimpleEscrow escrow = new SimpleEscrow(msg.sender, _seller, _owner);\n    uint256 id = nextId;\n    nextId = id + 1;\n    escrowById[id] = address(escrow);\n    escrows.push(address(escrow));\n    emit EscrowCreated(address(escrow), msg.sender, _seller, _owner);\n    return (id, address(escrow));\n  }\n\n  function escrowsCount() external view returns (uint256) {\n    return escrows.length;\n  }\n\n  function getEscrows() external view returns (address[] memory) {\n    return escrows;\n  }\n}\n"
      },
      "project/contracts/todo/contracts/Todo.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract Todo {\n  uint public todoCounter;\n\n  enum TaskState {\n    Pending,\n    Completed,\n    Cancelled,\n    Defaulted\n  }\n\n  struct Task {\n    uint id;\n    address admin;\n    string text;\n    TaskState status;\n    uint deadline;\n  }\n\n  mapping(uint => Task) tasks;\n  event TaskCreated(string text, uint deadline);\n\n  function createTask(\n    string memory text,\n    uint deadline\n  ) external returns (uint) {\n    require(bytes(text).length > 0, 'Text cannot be empty');\n    require(deadline > (block.timestamp + 600), 'Invalid deadline');\n\n    todoCounter++;\n\n    tasks[todoCounter] = Task(\n      todoCounter,\n      msg.sender,\n      text,\n      TaskState.Pending,\n      deadline\n    );\n\n    emit TaskCreated(text, deadline);\n    return todoCounter;\n  }\n\n  function getTask(uint id) external view returns (Task memory) {\n    return tasks[id];\n  }\n\n  function updateTask(\n    uint id,\n    string memory text,\n    uint deadline\n  ) external returns (uint) {\n    require(bytes(text).length > 0, 'Text cannot be empty');\n    require(\n      deadline > (block.timestamp + 600),\n      'Deadline cannot be less than 10 minutes'\n    );\n    require(tasks[id].admin == msg.sender, 'Only admin can update task');\n    tasks[id] = Task(id, msg.sender, text, TaskState.Pending, deadline);\n    return id;\n  }\n\n  function doneTask(uint id) external returns (uint) {\n    require(tasks[id].admin == msg.sender, 'Only admin can complete task');\n    tasks[id].status = TaskState.Completed;\n    return id;\n  }\n}\n"
      },
      "project/contracts/vault/contracts/vault.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ncontract TimelockedSavingsVault {\n    struct Vault {\n        uint256 amount;\n        uint256 unlockTime;\n        bool active;\n    }\n\n    uint256 public constant LOCK_DURATION = 24 hours; // Fixed lock duration for every deposit.\n\n    mapping(address => Vault) private vaults;\n\n    event Deposit(address indexed user, uint256 amount, uint256 unlockTime);\n    event Withdraw(address indexed user, uint256 amount);\n\n    function deposit(uint256 unlockTime) external payable {\n        require(msg.value > 0, \"Deposit must be > 0\");\n        require(unlockTime == block.timestamp + 24 hours, \"Unlock time must be exactly 24h\");\n        require(!vaults[msg.sender].active, \"Vault already active\");\n\n        vaults[msg.sender] = Vault({\n            amount: msg.value,\n            unlockTime: unlockTime,\n            active: true\n        });\n\n        emit Deposit(msg.sender, msg.value, unlockTime);\n    }\n\n    function withdraw() external {\n        Vault storage v = vaults[msg.sender];\n        require(v.active, \"No active vault\");\n        require(block.timestamp >= v.unlockTime, \"Too early\");\n        uint256 amount = v.amount;\n        require(amount > 0, \"No balance\");\n\n        v.amount = 0;\n        v.active = false;\n        v.unlockTime = 0;\n\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Withdraw failed\");\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function getVault(address user) external view returns (uint256 amount, uint256 unlockTime, bool active) {\n        Vault storage v = vaults[user];\n        return (v.amount, v.unlockTime, v.active);\n    }\n\n    receive() external payable {\n        revert(\"Direct ETH not allowed\");\n    }\n\n    fallback() external payable {\n        revert(\"Direct ETH not allowed\");\n    }\n}\n"
      }
    }
  }
}